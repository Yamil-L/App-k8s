from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, List
import os
import psycopg2
from psycopg2.extras import RealDictCursor
from contextlib import contextmanager

app = FastAPI(title="Text Processor API Gateway", version="1.0.0")

# CORS para permitir peticiones desde el frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Configuración de base de datos desde variables de entorno
DB_CONFIG = {
    "host": os.getenv("DB_HOST", "postgres"),
    "port": int(os.getenv("DB_PORT", "5432")),
    "database": os.getenv("DB_NAME", "textprocessor"),
    "user": os.getenv("DB_USER", "admin"),
    "password": os.getenv("DB_PASSWORD", "supersecret123")
}

@contextmanager
def get_db_connection():
    """Context manager para conexión a la base de datos"""
    conn = psycopg2.connect(**DB_CONFIG)
    try:
        yield conn
        conn.commit()
    except Exception as e:
        conn.rollback()
        raise e
    finally:
        conn.close()

# Modelos Pydantic
class TextRequest(BaseModel):
    text: str
    service: str  # "translate", "summary", "analytics", "improve", "keywords"
    options: Optional[dict] = {}

class TextResponse(BaseModel):
    id: int
    original_text: str
    processed_text: str
    service_used: str
    status: str

class HealthResponse(BaseModel):
    status: str
    database: str
    version: str

# Inicializar base de datos
@app.on_event("startup")
async def startup_event():
    """Crear tablas al iniciar la aplicación"""
    with get_db_connection() as conn:
        with conn.cursor() as cur:
            cur.execute("""
                CREATE TABLE IF NOT EXISTS text_requests (
                    id SERIAL PRIMARY KEY,
                    original_text TEXT NOT NULL,
                    processed_text TEXT,
                    service_used VARCHAR(50) NOT NULL,
                    status VARCHAR(20) DEFAULT 'pending',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            cur.execute("""
                CREATE INDEX IF NOT EXISTS idx_service_used 
                ON text_requests(service_used)
            """)
            cur.execute("""
                CREATE INDEX IF NOT EXISTS idx_created_at 
                ON text_requests(created_at DESC)
            """)

@app.get("/", response_model=dict)
async def root():
    """Endpoint raíz"""
    return {
        "message": "Text Processor API Gateway",
        "version": "1.0.0",
        "endpoints": {
            "health": "/health",
            "process": "/api/process",
            "history": "/api/history",
            "stats": "/api/stats"
        }
    }

@app.get("/health", response_model=HealthResponse)
async def health_check():
    """Health check endpoint"""
    db_status = "disconnected"
    try:
        with get_db_connection() as conn:
            with conn.cursor() as cur:
                cur.execute("SELECT 1")
                db_status = "connected"
    except Exception as e:
        db_status = f"error: {str(e)}"
    
    return {
        "status": "healthy" if db_status == "connected" else "unhealthy",
        "database": db_status,
        "version": "1.0.0"
    }

@app.post("/api/process", response_model=TextResponse)
async def process_text(request: TextRequest):
    """
    Procesar texto según el servicio solicitado
    Servicios: translate, summary, analytics, improve, keywords
    """
    if not request.text.strip():
        raise HTTPException(status_code=400, detail="Text cannot be empty")
    
    # Por ahora, simulamos el procesamiento
    # En producción, aquí se llamaría a los microservicios específicos
    processed_text = f"[{request.service.upper()}] Processed: {request.text[:50]}..."
    
    # Guardar en base de datos
    with get_db_connection() as conn:
        with conn.cursor(cursor_factory=RealDictCursor) as cur:
            cur.execute("""
                INSERT INTO text_requests (original_text, processed_text, service_used, status)
                VALUES (%s, %s, %s, %s)
                RETURNING id, original_text, processed_text, service_used, status
            """, (request.text, processed_text, request.service, "completed"))
            
            result = cur.fetchone()
    
    return result

@app.get("/api/history", response_model=List[TextResponse])
async def get_history(limit: int = 10):
    """Obtener historial de procesamiento"""
    with get_db_connection() as conn:
        with conn.cursor(cursor_factory=RealDictCursor) as cur:
            cur.execute("""
                SELECT id, original_text, processed_text, service_used, status
                FROM text_requests
                ORDER BY created_at DESC
                LIMIT %s
            """, (limit,))
            
            results = cur.fetchall()
    
    return results

@app.get("/api/stats")
async def get_stats():
    """Obtener estadísticas de uso"""
    with get_db_connection() as conn:
        with conn.cursor(cursor_factory=RealDictCursor) as cur:
            cur.execute("""
                SELECT 
                    service_used,
                    COUNT(*) as count,
                    COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed,
                    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending,
                    COUNT(CASE WHEN status = 'error' THEN 1 END) as errors
                FROM text_requests
                GROUP BY service_used
                ORDER BY count DESC
            """)
            
            stats = cur.fetchall()
            
            cur.execute("SELECT COUNT(*) as total FROM text_requests")
            total = cur.fetchone()
    
    return {
        "total_requests": total["total"],
        "by_service": stats
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
